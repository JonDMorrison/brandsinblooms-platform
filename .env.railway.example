# ============================================================================
# Railway Environment Configuration Template
# Optimized for Container Memory Management and Migration Reliability
# ============================================================================

# ====================
# CORE APPLICATION
# ====================
NODE_ENV=production
NEXT_TELEMETRY_DISABLED=1
HOSTNAME=0.0.0.0

# Railway automatically provides PORT - do not set it manually
# PORT will be assigned dynamically by Railway

# ====================
# SUPABASE CONFIGURATION
# ====================
# Required: Supabase connection details
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# Optional: Direct database URL for migrations (if needed)
# SUPABASE_DB_URL=postgresql://postgres:[password]@db.[project].supabase.co:5432/postgres

# ====================
# MIGRATION CONFIGURATION
# ====================
# Enable/disable migrations (default: true in production)
MIGRATION_ENABLED=true

# Use Node.js or shell-based migrations (default: false = shell)
USE_NODE_MIGRATIONS=false

# *** CRITICAL MEMORY SETTINGS ***
# Optimal memory allocation for Railway with 393GB system memory
# These settings prevent Go runtime OOM errors while maintaining efficiency

# Migration memory limit (MB) - INCREASED from 128MB to 512MB
# This allows sufficient memory for Go runtime page summary allocation
MIGRATION_MAX_MEMORY_MB=512

# Migration timeout (seconds) - sufficient for complex migrations
MIGRATION_TIMEOUT=300

# ====================
# GO RUNTIME OPTIMIZATION
# ====================
# Go garbage collection target (100 = default, lower = more frequent GC)
GOGC=100

# Go memory limit - automatically calculated as 90% of MIGRATION_MAX_MEMORY_MB
# GOMEMLIMIT=460m  # Auto-calculated: don't set manually

# Go max processes (limit to 2 for container efficiency)
GOMAXPROCS=2

# Go debug settings (disable for production)
# GODEBUG=gctrace=0

# ====================
# NODE.JS OPTIMIZATION
# ====================
# Node.js cluster workers for performance
NODE_CLUSTER_WORKERS=2

# Node.js memory limit (REDUCED from 512MB to 384MB to provide headroom for migrations)
# Set via NODE_OPTIONS in Dockerfile, not here

# ====================
# MONITORING & OBSERVABILITY
# ====================
# Migration monitoring settings
MONITOR_INTERVAL=10
MEMORY_WARNING_THRESHOLD=80
RECOVERY_ATTEMPTS=3
PROGRESSIVE_MEMORY_INCREASE=256

# ====================
# DEVELOPMENT/DEBUGGING
# ====================
# Skip migrations entirely (for emergency deployments)
# SKIP_MIGRATIONS=false

# Enable batch processing for large migrations (optional)
# USE_BATCH_PROCESSING=false

# Additional logging for debugging migration issues
# DEBUG_MIGRATIONS=false

# ============================================================================
# DEPLOYMENT NOTES
# ============================================================================
#
# 1. MEMORY ALLOCATION STRATEGY:
#    - Migration process: 512MB (with 100MB buffer for Go runtime overhead)
#    - Node.js application: 384MB (sufficient for SSR and API operations)
#    - System overhead: ~128MB for OS and container management
#    - Total usage: ~1GB peak during migrations, ~384MB steady state
#
# 2. RAILWAY PLATFORM CONSIDERATIONS:
#    - Railway provides 393GB total system memory
#    - Port is automatically assigned by Railway (do not set PORT)
#    - Health checks use dynamic PORT from environment
#    - Container restarts are handled gracefully with migration state tracking
#
# 3. MIGRATION RELIABILITY:
#    - 5-minute cooldown prevents restart loops on migration failures
#    - Progressive memory scaling for recovery attempts
#    - Background execution doesn't block application startup
#    - Real-time monitoring and recovery capabilities
#
# 4. TROUBLESHOOTING:
#    - Check migration logs: docker logs [container-id] | grep MIGRATION
#    - Monitor memory usage: /app/scripts/migration-monitor.sh health
#    - Force migration restart: rm /tmp/migrations/* && restart container
#
# 5. PERFORMANCE IMPACT:
#    - Startup time: No blocking (migrations run in background)
#    - Memory overhead: +384MB during migrations, minimal after completion
#    - CPU impact: Minimal with nice priority and process limits
#
# ============================================================================